let Post,mongoose,Joi;_b53‍.x([["getPostById",()=>getPostById],["write",()=>write],["list",()=>list],["read",()=>read],["remove",()=>remove],["update",()=>update]]);_b53‍.w("../../models/post",[["default",["Post"],function(v){Post=v}]]);_b53‍.w("mongoose",[["default",["mongoose"],function(v){mongoose=v}]]);_b53‍.w("joi",[["default",["Joi"],function(v){Joi=v}]]);



const { ObjectId } = mongoose.Types;

       const getPostById =async (ctx, next) => {
  const { id } = ctx.params;
  if (!ObjectId.isValid(id)) {
    ctx.status = 400; // Bad Request
    return;
  }
  try {
    const post = await Post.findById(id);
    if(!post) {
      ctx.status = 404;
      return;
    }
      ctx.state.post = post;
      return next();
    } catch (e) {
      ctx.throw(500, e);
    }
  };

       const write = async ctx => {
  const schema = Joi.object().keys({
    // 객체가 다음 필드를 가지고 있음을 검증
    title: Joi.string().required(), // required() 가 있으면 필수 항목
    body: Joi.string().required(),
    tags: Joi.array()
      .items(Joi.string())
      .required(), // 문자열로 이루어진 배열
  });

  // 검증 후, 검증 실패시 에러처리
  const result = Joi.validate(ctx.request.body, schema);
  if (result.error) {
    ctx.status = 400; // Bad Request
    ctx.body = result.error;
    return;
  }

  const { title, body, tags } = ctx.request.body;
  const post = new Post({
    title,
    body,
    tags,
    user: ctx.state.user,
  });
  try {
    await post.save();
    ctx.body = post;
  } catch (e) {
    ctx.throw(500, e);
  }
};

       const list = async ctx => {
  const page = parseInt(ctx.query.page || '1', 10);
  if(page < 1) {
    ctx.status = 400;
    return;
  }
  try{
  const posts = await Post.find()
  .sort({ _id: -1})  //내림차순 _id를 1로하면 오름차순
  .limit(20)  //제한하기
  .skip((page - 1) * 10)
  .exec();
const postCount = await Post.countDocuments().exec(0);
ctx.set('Last-Pages', Math.ceil(postCount / 10));
  ctx.body = posts
  .map(post => post.toJSON())
  .map(post => ({
    ...post,
    body:
    post.body.length < 200 ? post.body : `${post.body.slice(0, 100)}...`,
  }))
} catch(e) {
  ctx.throw(500, e);
 }
};

       const read = async ctx => {
 const { id } = ctx.params;
 try {
   const post = await Post.findById(id).exec();
   if(!post) {
     ctx.status = 404;
     return;
   }
   ctx.body = post;
 } catch(e) {
   ctx.throw(500, e);
 }
};

       const remove = async ctx => {
  const { id } = ctx.params;
  try{
    await Post.findByIdAndRemove(id).exec();
    ctx.status = 204;
  } catch(e) {
    ctx.throw(500, e);
  }
};

       const update = async ctx => {
  const { id } = ctx.params;
  // write 에서 사용한 schema 와 비슷한데, required() 가 없습니다.
  const schema = Joi.object().keys({
    title: Joi.string(),
    body: Joi.string(),
    tags: Joi.array().items(Joi.string()),
  });

  // 검증 후, 검증 실패시 에러처리
  const result = Joi.validate(ctx.request.body, schema);
  if (result.error) {
    ctx.status = 400; // Bad Request
    ctx.body = result.error;
    return;
  }


  try {
    const post = await Post.findByIdAndUpdate(id, ctx.request.body, {
      new: true,
    }).exec();
    if(!post) {
      ctx.status = 404;
      return;
    }
    ctx.body = post;
  } catch(e) {
    ctx.throw(500, e);
  }
};
